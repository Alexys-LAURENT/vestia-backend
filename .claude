# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Vestia Backend is an AdonisJS 6 application that provides a REST API for a fashion wardrobe management system. The app enables users to:
- Manage their clothing items (Items) with AI-powered image analysis
- Generate outfit recommendations (Looks) using AI
- Organize their wardrobe with detailed metadata (type, season, formality, colors, etc.)

## Common Commands

### Development
```bash
npm run dev          # Start development server with HMR
npm start            # Start production server
npm run build        # Build for production
```

### Code Quality
```bash
npm run lint         # Run ESLint
npm run format       # Format code with Prettier
npm run typecheck    # Type check with TypeScript
```

### Testing
```bash
npm test             # Run all tests with Japa
```

### Database
```bash
node ace migration:run      # Run pending migrations
node ace migration:rollback # Rollback last batch
node ace migration:fresh    # Drop all tables and re-run migrations
node ace make:migration     # Create new migration
```

### AdonisJS CLI
```bash
node ace list                    # List all available commands
node ace make:controller <name>  # Create new controller
node ace make:model <name>       # Create new model
node ace make:validator <name>   # Create new validator
```

## Architecture

### Framework & Patterns

The codebase follows AdonisJS conventions with a repository pattern:
- **Controllers** ([app/controllers/](app/controllers/)): Handle HTTP requests, validation, and response formatting. Controllers extend `AbstractController` which provides `buildJSONResponse()` helper.
- **Validators** ([app/controllers/*/validators.ts](app/controllers/)): VineJS schemas for request validation, co-located with controllers.
- **Repositories** ([app/repositories/](app/repositories/)): Encapsulate data access logic and complex queries.
- **Models** ([app/models/](app/models/)): Lucid ORM models with relationships and lifecycle hooks.
- **Services** ([app/services/](app/services/)): Reusable business logic, including:
  - `MediaService`: Image processing utilities
  - `OutfitGeneratorService`: AI-powered outfit generation with retry and fallback logic
  - `OutfitValidationService`: Outfit structure validation
  - `OutfitPromptBuilder`: AI prompt construction for outfit generation

### Domain Model

The application revolves around three main entities:

**User** ([app/models/user.ts](app/models/user.ts)):
- Manages authentication via access tokens (scrypt hashing)
- Has relationships: `hasMany(Item)`, `hasMany(Look)`

**Item** ([app/models/item.ts](app/models/item.ts)):
- Represents a clothing item with rich metadata:
  - `type`: Category from `ITEM_TYPES` constant (T-shirts, Pantalons, Robes, etc.)
  - `season`: printemps, été, automne, hiver
  - `formality`: très décontracté → formel (5 levels)
  - `mainColor`, `additionalColors`: Color information
  - `tags`: Array of descriptive tags (style, occasion, aesthetics)
  - `imageUrl`: Stored via Drive service
- Automatically deletes associated image on deletion (via `@beforeDelete()` hook)

**Look** ([app/models/look.ts](app/models/look.ts)):
- Represents an outfit/tenue composed of multiple Items
- `isAiGenerated`: Tracks if generated by AI or manually created
- `event`: Optional event/occasion description
- Many-to-many with Items via `looks_items` pivot table

### Path Aliases

Import paths use `#` prefix (configured in [package.json](package.json)):
```typescript
import Item from '#models/item'
import ItemsRepository from '#repositories/items_repository'
import { insertItemValidator } from '#controllers/items_controller/validators'
```

### AI Integration

The app uses two different AI providers for distinct features:

**Ollama (Local Model for Image Analysis)**:
- Location: [app/controllers/items_controller/controller.ts](app/controllers/items_controller/controller.ts:26-83)
- Uses `ollama-ai-provider-v2` package with local Ollama instance
- Default model: `qwen3-vl:2b` (configurable via `MODEL_NAME_FOR_ANALYSIS` env var)
- Analyzes clothing images to extract structured metadata
- Returns: type, colors, formality, season, tags, description in French
- Uses `generateObject()` with Zod schema validation for type-safe output
- Validates that image contains exactly one clothing item before analysis

**Google Gemini (Cloud Model for Look Generation)**:
- Main service: [app/services/outfit_generator_service.ts](app/services/outfit_generator_service.ts)
- Uses `@ai-sdk/google` package with `gemini-2.5-flash` model
- Requires `GOOGLE_GENERATIVE_AI_API_KEY` environment variable
- Generates complete outfits (looks) from user's entire wardrobe
- Architecture:
  - `OutfitGeneratorService`: Orchestrates AI generation, validation, and fallback
  - `OutfitValidationService`: Validates generated outfits against business rules
  - `OutfitPromptBuilder`: Constructs detailed prompts with wardrobe context
  - Constants defined in [constants/outfit_structure.ts](constants/outfit_structure.ts)
- Features:
  - Supports forced items (user-selected pieces that MUST be included)
  - Supports disliked items (pieces to avoid in the outfit)
  - Validates outfit structure with strict rules
  - Retry logic (3 attempts) with fallback to manual generation
- Outfit validation rules:
  - Must have (top + bottom) OR (dress) as base
  - Exactly 1 item per category (no duplicates: 2 tops, 2 bottoms, etc.)
  - Optional: outerwear, shoes, accessories
  - Total: 2-6 items per outfit

### Authentication

- Uses AdonisJS Auth with `tokensGuard` (access token-based auth)
- Configuration: [config/auth.ts](config/auth.ts)
- Tokens stored in database via `DbAccessTokensProvider`
- Middleware: `middleware.auth()` protects authenticated routes

### File Storage

- AdonisJS Drive service configured for local filesystem ([config/drive.ts](config/drive.ts))
- Images stored at: `{userId}/items/{itemId}.{ext}`
- Publicly accessible via `DRIVE_ROUTE_BASE_PATH` (configured in .env)
- Items automatically clean up their images on deletion

### Constants

Important constants are defined in [constants/item_types.ts](constants/item_types.ts):
- `ITEM_TYPES`: 13 clothing categories (T-shirts, Pantalons, Robes, etc.)
- `ITEM_SEASONS`: 4 seasons in French (printemps, été, automne, hiver)
- `ITEM_FORMALITIES`: 5 formality levels in French

**IMPORTANT**: These constants MUST stay synchronized with the frontend application. A comment in the file reminds developers to update both codebases when modifying these values.

Outfit structure constants are defined in [constants/outfit_structure.ts](constants/outfit_structure.ts):
- `OUTFIT_CATEGORIES`: Maps clothing types to outfit categories (tops, bottoms, dresses, etc.)
- `OUTFIT_CONSTRAINTS`: Min/max items per outfit (2-6 items)
- `getItemCategory()`: Helper to determine category from item type
- `isValidOutfitStructure()`: Validates outfit composition rules

## Environment Variables

Required variables defined in [start/env.ts](start/env.ts):

**Database (PostgreSQL)**:
- `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_DATABASE`

**Storage**:
- `DRIVE_DISK`: Storage driver (currently only `fs` supported)
- `DRIVE_FS_ROOT`: Root directory for file storage (e.g., "storage")
- `DRIVE_ROUTE_BASE_PATH`: Public URL path for serving files (e.g., "/uploads")

**AI Models**:
- `MODEL_NAME_FOR_ANALYSIS`: Ollama model name for image analysis (e.g., `qwen3-vl:2b`)
- `GOOGLE_GENERATIVE_AI_API_KEY`: Google AI API key for outfit generation with Gemini

**Note**: Ollama must be running locally for image analysis to work. Install with `brew install ollama` and run `ollama serve`.

## API Routes

Routes defined in [start/routes.ts](start/routes.ts):

**Auth** (`/auth`):
- `POST /login`, `/register`, `/logout`, `/check-username`

**Items** (`/items`):
- `POST /analyse` - Analyze clothing image with AI (no auth required)
- `POST /` - Create new item (auth required)
- `GET /` - List user's items with pagination/filtering
- `GET /:idItem` - Get single item
- `PUT /:idItem` - Update item
- `DELETE /:idItem` - Delete item (and its image)

**Looks** (`/looks`):
- `GET /` - List user's looks with pagination
- `POST /generate` - AI-generate outfit from wardrobe

## Testing

- Testing framework: Japa with `@japa/plugin-adonisjs`
- Test files location: [tests/](tests/)
- Bootstrap: [tests/bootstrap.ts](tests/bootstrap.ts)

## Hot Module Replacement

HMR is configured for rapid development ([package.json](package.json:68-73)):
- Controllers and middleware automatically reload on changes
- Uses `hot-hook` package

## Key Implementation Details

### Image Analysis Workflow
1. User uploads image via `POST /items/analyse`
2. `MediaService.getBase64FromImage()` converts to base64
3. Ollama local model analyzes image with French-language structured prompt
4. Returns clothing metadata (type, colors, formality, season, tags) or failure reason
5. Client then uses this data to create the item via `POST /items`

### Look Generation Workflow
The outfit generation process is now modularized across several services:

**Controller Layer** ([app/controllers/looks_controller/controller.ts](app/controllers/looks_controller/controller.ts)):
1. Authenticates user and validates request parameters
2. Fetches user's wardrobe items
3. Delegates generation to `OutfitGeneratorService`
4. Formats and returns response

**Service Layer** ([app/services/outfit_generator_service.ts](app/services/outfit_generator_service.ts)):
1. `prepareItems()`: Validates and organizes forced/disliked items
2. `tryAiGeneration()`: Attempts AI-powered outfit generation with retry logic
   - Uses `OutfitPromptBuilder` to construct detailed prompts
   - Calls Google Gemini API with structured schema
   - Uses `OutfitValidationService` to validate each attempt
   - Retries up to 3 times if validation fails
3. `generateFallback()`: Manual outfit generation if AI fails
   - Respects forced items
   - Adds complementary pieces (top + bottom, or dress)
   - Completes outfit with optional items (shoes, outerwear, accessories)

**Validation Rules** ([app/services/outfit_validation_service.ts](app/services/outfit_validation_service.ts)):
- Exactly 1 item per category (no 2 tops, 2 bottoms, etc.)
- Must have (top + bottom) OR (dress) as base
- Optional: outerwear, shoes, accessories
- Total: 2-6 items per outfit
- All forced items must be included

**Prompt Construction** ([app/services/outfit_prompt_builder.ts](app/services/outfit_prompt_builder.ts)):
- Builds wardrobe description organized by type
- Highlights forced items with special markers
- Lists disliked items to avoid
- Includes detailed outfit structure rules in French

### Repository Pattern
Repositories encapsulate query logic and should always be used in controllers:
- `ItemsRepository.getAllItemsForOneUserWithPaginatedAndFilters()`: Complex filtering with pagination
- `ItemsRepository.insertNewItem()`: Transaction-wrapped creation with image upload
- Never query models directly from controllers - always use repositories

### Authorization
Items and Looks are user-scoped. Controllers verify ownership before allowing modifications:
```typescript
if (item.idUser !== user.idUser) {
  throw new UnAuthorizedException()
}
```
